namespace CGAL {
/*!

\mainpage User Manual
\anchor Chapter_2D_Generalized_Barycentric_Coordinates
\cgalAutoToc

\authors Dmitry Anisimov, David Bommes, Kai Hormann, and Pierre Alliez


\section gbc_introduction Introduction

This package offers an efficient and robust implementation of 2D generalized barycentric
coordinates defined for simple 2D polygons. If coordinates with respect to multivariate
scattered points instead of a polygon are required, please refer to natural neighbor
coordinates from the package \ref chapinterpolation "2D and Surface Function Interpolation".

In particular, this package includes an implementation of \ref wp_example "Wachspress",
\ref mv_example "mean value", \ref dh_example "discrete harmonic", and \ref hm_example "harmonic"
coordinates, and provides some extra functions to compute barycentric coordinates with respect
to \ref seg_example "segments" and \ref tri_example "triangles".


\section gbc_interface Software Design

Mean value and harmonic coordinates are the most generic coordinates in this package,
because they allow an arbitrary simple polygon as input. Wachspress and discrete harmonic coordinates
are, by definition, limited to strictly convex polygons. Segment coordinates take as input
any non-degenerate segment, and triangle coordinates allow an arbitrary non-degenerate triangle.

Wachspress, discrete harmonic, mean value, and harmonic coordinates are all generalized
barycentric coordinates. However, while Wachspress, discrete harmonic, and mean value
coordinates can be computed analytically, harmonic coordinates cannot. They first need
to be approximated over a triangulation of the interior part of the polygon. Once approximated,
they can be evaluated analytically at any point inside the polygon.

For all analytic coordinates, we provide two algorithms. One has a linear time complexity,
but may suffer imprecisions near the polygon boundary, while the second one is precise
but has a quadratic time complexity. The user can choose the prefered algorithm by
specifying a `CGAL::Barycentric_coordinates::Computation_policy`.

All analytic barycentric coordinates for polygons can be computed either by instantiating a class
or through one of the free functions. Harmonic coordinates can be computed only by
instantiating a class that must be parameterized by a model of the concept `DiscretizedDomain_2`.
Segment and triangle coordinates can be computed only through the free functions.
See more in the \ref PkgBarycentricCoordinates2Ref "Reference Manual".

Any point in the plane may be taken as a query point. However, we do not recommend to
use Wachspress and discrete harmonic coordinates with query points outside the closure
of a polygon, because they are not well-defined for some of these points. The same holds
for harmonic coordinates, which are not defined at any point outside the polygon. See more in
Section \ref gbc_degeneracies.

The output of the computation is a set of coordinate values at the given query point
with respect to the polygon vertices. That means that the number of returned coordinates
per query point equals to the number of polygon vertices. The ordering of the coordinates
is the same as the ordering of polygon vertices.

All coordinates are parameterized by a traits class of the concept `BarycentricTraits_2`
that provides all necessary geometric primitives, predicates, and constructions, which are
required for the computation. All models of `Kernel` can be used. A polygon is provided
as a range of vertices with a \ref PkgPropertyMapRef "propery map" that maps a vertex
from the polygon to `CGAL::Point_2`.


\section gbc_examples Examples

In order to facilitate the process of learning this package, we provide various examples
with basic uses of different barycentric components.


\subsection seg_example Segment Coordinates

This example shows the use of the global function `CGAL::Barycentric_coordinates::segment_coordinates_2()`.
We compute coordinates at three green points along the segment \f$[v_0, v_1]\f$ and at two blue points outside this segment
but along its supporting line. The symmetry of the query points helps recognizing errors that
may have occured during construction of the example. The used `Kernel` is exact.

\anchor seg_coord_example
\cgalFigureBegin{seg_example, seg_coord_example.png}
Example's point pattern.
\cgalFigureEnd

\cgalExample{Barycentric_coordinates_2/segment_coordinates.cpp}


\subsection tri_example Triangle Coordinates

In this example, we show how to use the global function `CGAL::Barycentric_coordinates::triangle_coordinates_2()`.
We compute coordinates for three sets of points: interior (green), boundary (red), and exterior (blue).
Note that some of the coordinate values for the exterior points are negative.
The used `Kernel` is of floating precision.

\anchor tri_coord_example
\cgalFigureBegin{tri_example, tri_coord_example.png}
Example's point pattern.
\cgalFigureEnd

\cgalExample{Barycentric_coordinates_2/triangle_coordinates.cpp}


\subsection wp_example Wachspress Coordinates

In the following example, we generate 100 random points, then we take the convex hull
of this set of points as our polygon, and compute Wachspress coordinates at
all the generated points. The used `Kernel` is of floating precision.

\cgalExample{Barycentric_coordinates_2/Wachspress_coordinates.cpp}


\subsection dh_example Discrete Harmonic Coordinates

In this example, we compute discrete harmonic coordinates for a set of green (interior),
red (boundary), and blue (exterior) points with respect to a unit square. We also show
that package accepts various containers, both random access and not, different property maps,
and lets the user choose a `CGAL::Barycentric_coordinates::Computation_policy`. For points
on the polygon boundary, we use a free function `CGAL::Barycentric_coordinates::boundary_coordinates_2()`.
The used `Kernel` is exact.

\anchor dh_coord_example
\cgalFigureBegin{dh_example, dh_coord_example.png}
Example's point pattern.
\cgalFigureEnd

\cgalExample{Barycentric_coordinates_2/discrete_harmonic_coordinates.cpp}


\subsection mv_example Mean Value Coordinates

This is an example that shows how to compute mean value coordinates for a set of green points
in a star-shaped polygon. We note that this type of coordinates is well-defined for such a concave polygon
while Wachspress and discrete harmonic coordinates are not. However, it may give negative
coordinate values for points outside <a href="https://en.wikipedia.org/wiki/Star-shaped_polygon">the polygon's kernel</a>
(shown in red). We speed up the computation using the linear time complexity algorithm by specifying
the corresponding `CGAL::Barycentric_coordinates::Computation_policy`. The used `Kernel` is inexact.

\anchor mv_coord_example
\cgalFigureBegin{mv_example, mv_coord_example.png}
Example's point pattern.
\cgalFigureEnd

\cgalExample{Barycentric_coordinates_2/mean_value_coordinates.cpp}


\subsection hm_example Harmonic Coordinates
This example shows how to discretize the interior part of the \ref terrain_example_fig "polygon"
and compute harmonic coordinates at the vertices of the discretized domain, which is
a Delaunay triangulation in our case. Once computed, harmonic coordinate functions can be
evaluated at any point in the closure of the polygon. To show that, we compute the barycenter
of each triangle and evaluate harmonic coordinates at this barycenter. Since harmonic
coordinates can only be approximated, the used `Kernel` is of floating precision.

\anchor hm_coord_example
\cgalExample{Barycentric_coordinates_2/harmonic_coordinates.cpp}


\subsection height_inter_example Height Interpolation for Terrain Modeling

This is an advanced example that shows how to use generalized barycentric coordinates
for height interpolation with applications to terrain modeling. It also shows how to use
a non-default traits class with our package instead of a `Kernel` traits class.
Suppose we know the boundary of three-dimensional piece of terrain that can be represented
as a polygon with several three-dimensional vertices, where the third dimension gives
the corresponding height. The task is to propagate the height from the known sample points
on the boundary to the polygon's interior. This gives an approximate estimation of
the terrain's surface in this region.

\anchor terrain_example_fig
\cgalFigureBegin{terrain_example, terrain.png}
A 2D polygon with 50 vertices representing a piece of terrain with convex and concave parts. The height is not shown.
\cgalFigureEnd

In this example, we project a 3D polygon orthogonally onto the 2D plane using the class
`CGAL::Projection_traits_xy_3`, triangulate its interior using the class `CGAL::Barycentric_coordinates::Delaunay_domain_2`,
and compute mean value coordinates at the vertices of this triangulation with respect to the polygon vertices.
Finally, we interpolate the height data from the polygon boundary to its interior
using the computed coordinates and the global interpolation function from the
package \ref chapinterpolation "2D and Surface Function Interpolation".

\anchor terrain_example
\cgalExample{Barycentric_coordinates_2/terrain_height_modeling.cpp}

As a result, we get a smooth function inside the polygon that approximates the underlying terrain surface.

\cgalFigureBegin{terrain_interpolation_example, terrain_interpolation.png}
The interpolated data. The color bar represents the corresponding height.
\cgalFigureEnd


\subsection af_example Affine Coordinates
This is another advanced example, where we show how the
<a href="https://en.cppreference.com/w/cpp/language/lambda">lambda expression</a>
can be used to define a model of generalized barycentric coordinates. To make this example
useful, we implement affine generalized coordinates for a set of scattered points.
The used `Kernel` is of floating precision.

\anchor af_coord_example
\cgalExample{Barycentric_coordinates_2/affine_coordinates.cpp}


\section gbc_degeneracies Edge Cases

Not all presented coordinates are general enough to handle any query point in the plane, that is
why we highly recommend to address this section in order to learn what can be expected from
each coordinate function. If you want to get more mathematical details about each coordinate
function as well as complete history and theory behind barycentric coordinates, you should
read \cgalCite{cgal:bc:hs-gbcicg-17}.


\anchor compute_seg_coord
\subsection gbc_deg_segment_coordinates Segment Coordinates

Segment coordinates can be computed exactly if an exact data type is chosen.
The segment itself, with respect to which we compute coordinates, must be non-degenerate.
If both conditions are satisfied, then the computation never fails. However, to compute coordinates,
the user must be sure about the query point being exactly on the line \f$L\f$ supporting the segment.
Since in many applications this is not the case, and a query point may lie very close but not exactly on this line,
the class is also able to handle this situation.

\cgalFigureBegin{seg_coord_projection, seg_coord_projection.png}
The orthogonal projection \f$p'\f$ of the vector \f$p\f$ (green) onto the vector \f$q\f$ (red).
\cgalFigureEnd

Suppose that some query point \f$v\f$ does not lie exactly on the line \f$L\f$,
but is some distance \f$d\f$ away as shown in the figure above. If we want to compute
the segment barycentric coordinate \f$b_1(v)\f$ with respect to the vertex \f$v_1\f$,
we first find the orthogonal projection \f$p'\f$ of the vector \f$p\f$ onto the vector \f$q\f$ and
then normalize it by the length of \f$q\f$. This gives the segment barycentric
coordinate \f$b_1(v') = b_1(v)\f$ if \f$v\f$ lies exactly on the line.

\b Warning: do not abuse the feature described above, because it does not give correct
segment barycentric coordinates for the point \f$v\f$ but rather those for \f$v'\f$.
Moreover, segment barycentric coordinates for a point \f$v\f$, which does not lie exactly on the line \f$L\f$,
do not exist. But if the non-zero distance \f$d\f$ is due to some numerical instability
when computing the location of the point \f$v\f$ or any other problem,
which causes the point to be not exactly on the line, the final segment coordinates will be,
at least approximately, correct.

With inexact data types, the resulting coordinate values are correct up to the precision of the chosen type.


\subsection gbc_deg_triangular_coordinates Triangle Coordinates

These coordinates can be computed exactly if an exact data type is chosen, for any query point
in the plane and with respect to any non-degenerate triangle. No special cases are handled.
The computation always gives the correct result. The notion of correctness depends on the precision
of the used data type. Note that for exterior points some coordinate values will be negative.


\subsection gbc_deg_wachspress_coordinates Wachspress Coordinates

Wachspress coordinates are well-defined in the closure of any <em>strictly convex polygon</em>.
Therefore, when using an exact data type, for any query point from the polygon's closure,
these coordinates are computed exactly and no false result is expected. For inexact data types,
the resulting precision of the computation is due to the involved algorithm and chosen data type.
In the following paragraph, we discuss two available algorithms for computing Wachspress coordinates.
The chosen algorithm is defined by `CGAL::Barycentric_coordinates::Computation_policy`.

\anchor wp_polygon
\cgalFigureBegin{wp_notations, wp_notations.png}
Notation for Wachspress coordinates.
\cgalFigureEnd

To compute Wachspress weights, we follow \cgalCite{cgal:bc:fhk-gcbcocp-06} and use the formula

<center>\f$w_i = \frac{C_i}{A_{i-1}A_i}\f$</center>

with \f$i = 1\dots n\f$ where \f$n\f$ is the number of polygon vertices.
In order to compute the coordinates, we normalize these weights,

<center>\f$b_i = \frac{w_i}{W^{wp}}\qquad\f$ with \f$\qquad W^{wp} = \sum_{j=1}^n w_j.\f$</center>

This formula becomes unstable when approaching the boundary of the polygon (\f$\approx 1.0e-10\f$ and closer).
To fix the problem, we modify the weights \f$w_i\f$ as

<center>\f$\bar{w}_i = C_i\prod_{j\not=i-1,i} A_j\f$.</center>

After the normalization as above, this gives us the precise algorithm to compute Wachspress coordinates
but with \f$O(n^2)\f$ performance only. The max speed \f$O(n)\f$ algorithm uses the standard
weights \f$w_i\f$. Note that mathematically this modification does not change the coordinates. But you should
be cautious when using the unnormalized Wachspress weights. In that case, you must choose the
\f$O(n)\f$ type.

It is known that for strictly convex polygons the denominator's zero set of the
Wachspress coordinates (\f$W^{wp} = 0~\f$) is a curve, which (in many cases) lies quite
far away from the polygon. Speaking precisely, it interpolates the intersection points of
the continuations of the polygon edges. Therefore, the computation of Wachspress coordinates
outside the polygon is possible only at points that do not belong to this curve.

\cgalFigureBegin{wp_zero_set, wp_zero_set.png}
Zero set (red) of the Wachspress coordinates' denominator \f$W^{wp}\f$ for a non-regular hexagon.
\cgalFigureEnd

\b Warning: we do not recommend to use Wachspress coordinates for exterior points!


\subsection gbc_deg_discrete_harmonic_coordinates Discrete Harmonic Coordinates

Discrete harmonic coordinates have the same requirements as Wachspress coordinates.
They are well-defined in the closure of any <em>strictly convex polygon</em> and,
if an exact data type is chosen, they are computed exactly. But, unlike Wachspress basis functions,
these coordinates are not necessarily positive. In particular, the weight \f$w_i\f$ is positive
if and only if \f$\alpha+\beta < \pi\f$ (see the figure below for notation). For inexact data types,
the precision of the computation is due to the involved algorithm and chosen data type. Again,
we describe two algorithms to compute the coordinates: one is of max precision and one is of max speed.

\anchor dh_polygon
\cgalFigureBegin{dh_notations, dh_notations.png}
Notation for discrete harmonic coordinates.
\cgalFigureEnd

To compute discrete harmonic weights, we follow \cgalCite{cgal:bc:fhk-gcbcocp-06} and use the formula

<center>\f$w_i = \frac{r_{i+1}^2A_{i-1}-r_i^2B_i+r_{i-1}^2A_i}{A_{i-1}A_i}\f$</center>

with \f$i = 1\dots n\f$ where \f$n\f$ is the number of polygon vertices.
In order to compute the coordinates, we normalize these weights,

<center>\f$b_i = \frac{w_i}{W^{dh}}\qquad\f$ with \f$\qquad W^{dh} = \sum_{j=1}^n w_j.\f$</center>

This formula becomes unstable when approaching the boundary of the polygon (\f$\approx 1.0e-10\f$ and closer).
To fix the problem, similarly to the previous subsection, we modify the weights \f$w_i\f$ as

<center>\f$\bar{w}_i = (r_{i+1}^2A_{i-1}-r_i^2B_i+r_{i-1}^2A_i)\prod_{j\not=i-1,i} A_j\f$.</center>

After the normalization as above, this gives the precise algorithm to compute discrete harmonic coordinates
but with \f$O(n^2)\f$ performance only. The max speed \f$O(n)\f$ algorithm uses the standard
weights \f$w_i\f$. Again, mathematically this modification does not change the coordinates,
but you should be cautious when using the unnormalized discrete harmonic weights. In that case,
you must choose the \f$O(n)\f$ type.

\b Warning: as for Wachspress coordinates, we do not recommend to use discrete harmonic coordinates
for exterior points, because the curve \f$W^{dh} = 0\f$ may have several components,
and one of them interpolates the polygon vertices. However, if you are sure that
the query point does not belong to this curve, you can compute the coordinates
as shown in \ref dh_example " this example".


\subsection gbc_deg_mean_value_coordinates Mean Value Coordinates

Unlike the previous coordinates, mean value coordinates cannot be computed exactly due to
an inevitable square root operation. Although, if an exact data type is used, the default precision
of the computation depends only on two \cgal functions: `CGAL::to_double()` and `CGAL::sqrt()`.
On the other hand, mean value coordinates are well-defined everywhere in the plane for any simple polygon.
In addition, if your traits class provides a more precise version of the square root function,
the final precision of the computation with exact data types will depend only on the precision of that function.

\anchor mv_polygon
\cgalFigureBegin{mv_notations, mv_notations.png}
Notation for mean value coordinates.
\cgalFigureEnd

For these coordinates we also have two algorithms: one is of max precision and one is of max speed.
The first one works everywhere in the plane, and the precision of the computation depends only
on the chosen data type, including the remarks above. This algorithm is based on the following weight
formula from \cgalCite{cgal:bc:f-wmvc-14}

<center>\f$w_i = \sigma_i\bar{w}_i\qquad\f$ with \f$\qquad\bar{w}_i = (r_{i-1}r_{i+1}-d_{i-1}d_{i+1})^{1/2}\prod_{j\not= i-1,i}(r_jr_{j+1} + d_jd_{j+1})^{1/2}\qquad\f$
where \f$\qquad r_i = \|d_i\|.\f$</center>

Since \f$\bar{w}_i\f$ is always positive, we have to append to it the proper sign \f$\sigma_i\f$
of the signed mean value weight, which can be found efficiently (see the figures below).
Basically, this weight is always positive to the left of the red piecewise linear curve,
and it is negative to the right of this curve, moving in the counterclockwise direction.

\cgalFigureBegin{mv_weight_signs, mv_weight_signs_convex.png, mv_weight_signs_concave.png}
Signs of the mean value weight \f$w_i\f$ depending on the region with respect to a
convex polygon \f$P\f$ and a concave polygon \f$P'\f$.
\cgalFigureEnd

After the normalization of these weights as before

<center>\f$b_i = \frac{w_i}{W^{mv}}\qquad\f$ with \f$\qquad W^{mv} = \sum_{j=1}^n w_j\f$</center>

we obtain the max precision \f$O(n^2)\f$ algorithm. The max speed O(n) algorithm computes the
weights \f$w_i\f$ using the pseudocode from <a href="http://www.inf.usi.ch/hormann/nsfworkshop/presentations/Hormann.pdf">here</a>.
These weights

<center>\f$w_i = \frac{t_{i-1} + t_i}{r_i}\qquad\f$
with \f$\qquad t_i = \frac{\text{det}(d_i, d_{i+1})}{r_ir_{i+1} + d_id_{i+1}}\f$</center>

are also normalized. Note that they are unstable if a query point is closer than \f$\approx 1.0e-10\f$
to the polygon boundary, similarly to Wachspress and discrete harmonic coordinates and
you should be cautious when using the unnormalized mean value weights. In that case, you must choose the
\f$O(n)\f$ type.


\subsection gbc_deg_harmonic_coordinates Harmonic Coordinates

Harmonic coordinates are the only coordinates in this package, which are guaranteed to be
non-negative in the closure of any simple polygon and satisfy all properties of barycentric
coordinates, however the nice properties come with the fact that these coordinates are
well-defined only inside a polygon. If an exterior query point is provided, its coordinates
are set to zero.

Another disadvantage of these coordinates is that they cannot be computed
exactly, because harmonic coordinates do not have a simple closed-form expression and
have to be approximated. The classical way to approximate these coordinates is
by discretizing over the space of piecewise linear functions with respect to
a triangulation of the polygon. The denser triangulation of the interior part of
the polygon, the better approximation of the coordinates. To get a high quality
approximation of the coordinates, the user should provide a rather dense partition
of the polygon's interior domain that in turn leads to higher running times when
computing the coordinates.

\cgalFigureBegin{terrain_triangulation, terrain_triangulation.png}
Sparse triangulation of the polygon's interior domain (left): lower running times,
lower coordinates quality; dense triangulation (right): higher running times,
higher coordinates quality.
\cgalFigureEnd

From all this follows, that any exact `Kernel` will be rejected and it is not possible
to compute analytic harmonic weights. However, once the coordinates computed at the
vertices of the triangulation, they can be evaluated analytically at any interior
query point. To do that, we first locate a triangle that contains the query point
and then linearly interpolate harmonic coordinates defined at the vertices of this
triangle to the query point with the help of \ref gbc_deg_triangular_coordinates "triangle coordinates".


\section gbc_performance Performance

Apart from the most important requirement on barycentric coordinates to be as precise as possible,
it is very important for them to be as fast as possible to compute. These coordinates are used
in many applications where they must be computed for millions of points and, thus, the real time usage
of coordinates is crucial. When writing the code, we tried to fulfil this important requirement,
and in this section we present a few results about the computation times of the implemented coordinates.

The structure of the speed test that we use to evaluate the running times consists
of computing coordinate values (or weights) at >= 1 million strictly interior points
with respect to a polygon (or triangle, or segment). At each iteration of the loop,
we create a query point and compute its coordinates. We run this loop 10 times in a row,
and the time presented in the log-log scale plot at the end of the section is the arithmetic
mean of all trials. The time presented in the plot is for analytic coordinates only since
harmonic coordinates of a reasonable (application-dependent) quality are much slower to
compute and cannot be fairly compared to the analytic coordinate functions.

The time to compute coordinates depends on many factors such as memory allocation, input kernel, output container,
number of points, etc. In our tests, we used the most standard C++ and \cgal features with minimum memory allocation.
Therefore, the final time presented is the average time that can be expected without deep optimization
but still with efficient memory allocation. It also means that it may vary depending on the usage of the package.

For all tests above, we used a MacBook Pro 2011 with 2 GHz Intel Core i7 processor (2 cores)
and 8 GB 1333 MHz DDR3 memory. The installed operating system was OS X 10.9 Maverick.
In order to compile the speed test suite, we used the Clang 5.0 64bit compiler.
The resulting timings for all closed-form coordinates can be found in the figure below.

\cgalFigureBegin{analytic_timings, analytic_timings.png}
Time in seconds to compute \f$n\f$ coordinate values for a polygon with \f$n\f$ vertices
at 1 million points with the max speed \f$O(n)\f$ algorithms (dashed) and the max precision \f$0(n^2)\f$ algorithms (solid)
for Wachspress (blue), discrete harmonic (red), and mean value (green) coordinates.
\cgalFigureEnd

From the figure above it is easy to see that the \f$O(n^2)\f$ algorithm is as fast
as the \f$O(n)\f$ algorithm if we have a polygon with a small number of vertices.
But as the number of vertices is increased, the linear algorithm outperforms the squared one,
as expected. One of the reasons for this behavior is that for a small number of vertices
the multiplications of \f$n-2\f$ elements inside the \f$O(n^2)\f$ algorithm take almost the
same time as the corresponding divisions in the \f$O(n)\f$ algorithm. For a polygon with
many vertices, these multiplications are much slower.


\section gbc_acknowledgments Acknowledgments
The authors wish to thank <a href="https://cs.nyu.edu/~teseo/">Teseo Schneider</a>
and Randolf Schaerfig for helpful comments and discussions. We also appreciate the
great effort invested in this package by our reviewers Andreas Fabri, SÃ©bastien Loriot,
and Efi Fogel. In 2018, this package was modified and improved by Keyu Chen and Dmitry Anisimov
during the Google Summer of Code.
*/
}
